--@name Vegetation Painter
--@author Cheezus
--@shared

--[[
Basic usage:
0. Start Hammer on the SAME VERSION of the map you're currently playing on, you may need to do a fresh compile
1. Define default radius and physprops you want the vegetation to spawn on
2. Define whatever foliage items you want placed using table vegetation.items below
3. Spawn the chip and hold your use key (default E) to place foliage and your walk key (default ALT) to erase
4. Type /export to export current vegetation stuff to Hammer
5. Type /clean to remove current vegetation stuff from Hammer (in case you've made a mistake)
    5.1. This will NOT work if you despawn and respawn the chip, in that case you need to remove the vegetation
        in hammer manually. Sorry!
6. Optional - link this chip to a Starfall HUD component to view the area where foliage will appear/be removed
--]]

local radius = 500 --Default radius to paint foliage in, in source units

if SERVER then

    local vegetation = {}
    
    --Spawn vegetation items only on terrain using these physical properties - check site below for numbers
    --https://wiki.garrysmod.com/page/Enums/MAT
    vegetation.physProps = {
        85 --Grass
    }
    
    --[[
    Foliage item format:
        model: What model to use for that item of foliage
        density: How often this item appears relative to all other items
        radius: Distance from the center of the item to not spawn other similar-type foliage, in source units
        heightOffset: Height offset above ground, in source units
        maxAngle: Don't spawn the item on terrain steeper than this angle, in degrees
        useGroundAngle: Make this item conform to the angle of the terrain (good for grass and bushes)
        type: Items of dissimilar types will ignore eachother in terms of whether they can spawn in a certain
            location or not
        (Optional) fadeStartEnd: Distances at which the item starts and stops fading
    --]]
    
    vegetation.items = {
        {
            model = "models/props_foliage/tree_pine05.mdl",
            density = 100,
            radius = 150,
            heightOffset = 0,
            maxAngle = 25,
            useGroundAngle = false,
            type = "tree",
            fadeStartEnd = nil
        },
        
        {
            model = "models/props_foliage/tree_pine04.mdl",
            density = 100,
            radius = 150,
            heightOffset = 0,
            maxAngle = 25,
            useGroundAngle = false,
            type = "tree",
            fadeStartEnd = nil
        },
        
        {
            model = "models/props_foliage/tree_pine06.mdl",
            density = 100,
            radius = 150,
            heightOffset = 0,
            maxAngle = 25,
            useGroundAngle = false,
            type = "tree",
            fadeStartEnd = nil
        },
        
        {
            model = "models/props_foliage/tree_dead01.mdl",
            density = 20,
            radius = 150,
            heightOffset = 0,
            maxAngle = 25,
            useGroundAngle = false,
            type = "tree",
            fadeStartEnd = nil
        },
        
        {
            model = "models/props_foliage/tree_pine_large.mdl",
            density = 20,
            radius = 150,
            heightOffset = 0,
            maxAngle = 25,
            useGroundAngle = false,
            type = "tree",
            fadeStartEnd = nil
        },
    }
    
    vegetation.data = {} --stupid workaround for stupid bug

    vegetation.sumOfWeights = 0
    for _,item in pairs(vegetation.items) do
        vegetation.sumOfWeights = vegetation.sumOfWeights + item.density
    end
    
    local function weightedSelection()
        local randomWeight = math.rand(1, vegetation.sumOfWeights)
        for _,item in pairs(vegetation.items) do
            randomWeight = randomWeight - item.density
            if randomWeight <= 0 then
                return item
            end
        end
    end
    
    local function vecDiff(v1,v2)
        return math.deg(math.acos(v1:dot(v2)/(v1:getLength()*v2:getLength())))
    end
    
    if prop.spawnRate() < 100 then
        print("[VegetationPainter] WARNING: Increase sf_props_burstrate and sf_props_burstmax to >100 before using or this chip may error!")
    end
    
    timer.create("paint",0,0,function()
        if owner():keyDown(IN_KEY.USE) then
            local flag = false
            
            --Select foliage item at random
            local item = weightedSelection()
            
            --Get where owner is looking
            local eyeTrace = trace.trace(owner():getEyePos(),owner():getEyePos()+owner():getEyeAngles():getForward()*100000,find.all())
            
            --Select a random position and angle based on the above position
            local pos = eyeTrace.HitPos + Vector(math.rand(-radius,radius),math.rand(-radius,radius),0)
            local ang = Angle(math.rand(-1,1),math.rand(0,359),math.rand(-1,1))
            
            --Trace the position from above to determine its properties
            local groundTrace = trace.trace(pos + Vector(0,0,1000),pos + Vector(0,0,-100))
            
            if item.useGroundAngle == true then
                ang = groundTrace.HitNormal:getAngle() + Angle(90,0,0)
            end
            
            --Check radius of nearby foliage to prevent spawning inside eachother
            find.inSphere(pos,item.radius,function(ent)
                if not vegetation.data[ent] then return false end
                if vegetation.data[ent].type == item.type and (ent:getPos()-pos):getLength() < item.radius then flag = true end
            end)
            if flag == true then return false end
            
            --Ensure ground is one of the physprops to receive foliage
            flag = true
            for _,mat in pairs(vegetation.physProps) do
                if groundTrace.MatType == mat then flag = false end
            end
            if flag == true then return false end
            
            --Ensure the ground isn't too steep for the foliage
            if vecDiff(groundTrace.HitNormal,Vector(0,0,1)) > item.maxAngle then return false end
            
            local tree = prop.create(trace.trace(pos + Vector(0,0,1000),pos + Vector(0,0,-1000)).HitPos+Vector(0,0,item.heightOffset),ang,item.model,true)
            vegetation.data[tree] = {}
            vegetation.data[tree].type = item.type
            if item.fadeStartEnd then vegetation.data[tree].fadeStartEnd = item.fadeStartEnd end
        end
        
        if owner():keyDown(IN_KEY.WALK) then
            ents = find.inSphere(owner():getEyeTrace().HitPos,radius)
            for _,v in pairs(ents) do
                if isValid(v) and vegetation.data[v] and vegetation.data[v].type ~= nil then v:remove() end
            end
        end
    end)
    
    function secondsToClock(seconds)
        local seconds = tonumber(seconds)
        
        if seconds <= 0 then
            return "00:00:00"
        else
            hours = string.format("%02.f", math.floor(seconds/3600))
            mins = string.format("%02.f", math.floor(seconds/60 - (hours*60)))
            secs = string.format("%02.f", math.floor(seconds - hours*3600 - mins *60))
            milisecs = string.format("%02.f", math.round((seconds%1)*100))
            return mins..":"..secs.."."..milisecs
        end
    end
    
    function canRun(quota)
        if quotaAverage() > quotaMax() * quota or quotaUsed() > quotaMax() * quota then return false end
        return true
    end
    
    if not hammer then print("WARNING: Hammer library not detected, get it at https://github.com/CheezusChrust/Starfall-Hammer-Library") end
    
    hook.add("PlayerSay","chatmsg",function(ply,text)
        if ply == owner() then
            chat = string.explode(" ",text)
            
            if chat[1] == "/radius" then
                if chat[2] then
                    radius = tonumber(chat[2])
                    print("Radius set to " .. chat[2] .. " units")
                    net.start("radius")
                    net.writeInt(radius,16)
                    net.send()
                else
                    print("Please specify a radius")
                end
                return ""
            end
            
            if chat[1] == "/export" then
                if hammer then
                    local queue = find.byClass("prop_physics",function(ent) if vegetation.data[ent] then return true end end)
                    
                    hammer.startSession()
                    
                    print("Export started - THIS MAY TAKE A WHILE")
                    
                    local count = 0
                    local startTime = timer.systime()
                    timer.create("processQueue",0,0,function()
                        while #queue > 0 and canRun(0.5) do
                            local ent = queue[#queue]
                            count = count + 1
                            
                            try(function()
                                hammer.createProp("static",ent:getModel(),ent:getPos(),ent:getAngles())
                            end,function(err) print(err) end)
                            
                            data = vegetation.data[ent]
                            if data.fadeStartEnd then
                            
                                try(function()
                                    hammer.setKeyValue("prop_static",ent:getPos(),"fademindist",tostring(data.fadeStartEnd[1]))
                                    hammer.setKeyValue("prop_static",ent:getPos(),"fademaxdist",tostring(data.fadeStartEnd[2]))
                                end,function(err) print(err) end)
                                
                            end
                            table.remove(queue)
                        end
                        
                        if #queue == 0 then
                            print("Exported " .. count .. " entities in " .. secondsToClock(timer.systime()-startTime))
                            hammer.endSession()
                            timer.remove("processQueue")
                        end
                    end)
                else
                    print("Could not export due to missing Hammer library - get it at https://github.com/CheezusChrust/Starfall-Hammer-Library")
                end
                
                return ""
            end
            
            if chat[1] == "/clear" then
                if hammer then
                    local queue = find.byClass("prop_physics",function(ent) if vegetation.data[ent] then return true end end)
                    
                    hammer.startSession()
                    
                    print("Cleanup started...")
                    
                    local count = 0
                    local startTime = timer.systime()
                    timer.create("processQueue",0,0,function()
                        while #queue > 0 and canRun(0.5) do
                            local ent = queue[#queue]
                            count = count + 1
                            try(function()
                                hammer.removeEntity("prop_static",ent:getPos())
                            end,function()
                                print("Tried to clear a non-existent entity!")
                                timer.remove("processQueue")
                            end)
                            table.remove(queue)
                        end
                        
                        if #queue == 0 then
                            print("Removed " .. count .. " entities in " .. secondsToClock(timer.systime()-startTime))
                            hammer.endSession()
                            timer.remove("processQueue")
                        end
                    end)
                else
                    print("Could not clear due to missing Hammer library - get it at https://github.com/CheezusChrust/Starfall-Hammer-Library")
                end
                
                return ""
            end
            
        end
    end)
    
else
    
    net.receive("radius",function()
        radius = net.readInt(16)
    end)

    hook.add("drawHud","hud",function()
        render.pushViewMatrix({type="3D"})
        
        local hitPos = player():getEyeTrace().HitPos
        
        render.setColor(Color(0,255,0))
        render.draw3DWireframeBox(hitPos,Angle(0),Vector(radius):setZ(500),Vector(-radius):setZ(0))
    end)
end